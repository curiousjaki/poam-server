use std::str::FromStr;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    VERIFIABLE_PROCESSING_ELF,VERIFIABLE_PROCESSING_ID, COMPOSITE_PROVING_ELF, COMPOSITE_PROVING_ID
};
use operations::Operation;
use anyhow::Error;
use risc0_zkvm::{default_prover,  ExecutorEnv, Receipt};
use tonic::{transport::Server, Request, Response, Status};
use proto::verifiable_processing_service_server::{
     VerifiableProcessingService, VerifiableProcessingServiceServer,
    };
use proto::{CompositionRequest, CompositionResponse, Proof, ProveRequest, ProveResponse, VerifyRequest, VerifyResponse};

pub mod proto {
    tonic::include_proto!("poam");
}

#[derive(Default)]
pub struct MyProver;

#[tonic::async_trait]
impl VerifiableProcessingService for MyProver {
    async fn prove(
        &self,
        request: Request<ProveRequest>,
    ) -> Result<Response<ProveResponse>, Status> {
        //println!("Got a request: {:?}", request);

        let request = request.into_inner();
        let a = request.variable_a;
        let b = request.variable_b;
        let operation = request.operation;
        let receipt = prove_method(a, b, Operation::from_str(&operation).unwrap());
        let reply = ProveResponse {
            //receipt: Some(receipt.into()),
            response_value: 0.0,
            proof_response: Some(Proof {
                image_id: VERIFIABLE_PROCESSING_ID.to_vec(),
                receipt: bincode::serialize(&receipt).unwrap(),
            }),
            proof_chain: vec![Proof {
                image_id: VERIFIABLE_PROCESSING_ID.to_vec(),
                receipt: bincode::serialize(&receipt).unwrap(),
            }],
        };
        Ok(Response::new(reply))
    }

    async fn compose(
        &self,
        request: Request<CompositionRequest>,
    ) -> Result<Response<CompositionResponse>, Status> {
        let request = request.into_inner();
        let receipts: Vec<Receipt> = request.proof_chain.iter().map(|proof| {
            let receipt: Receipt = bincode::deserialize(&proof.receipt).unwrap();
            receipt
        }).collect();

        let composite_receipt = perform_composite_prove(receipts,VERIFIABLE_PROCESSING_ID).expect("Failed to prove composite receipt");

        // TODO: Implement code for retrieving receipt journal here.

        let reply = CompositionResponse {
            proof_response: Some(Proof {
                image_id: vec![0],
                receipt: bincode::serialize(&composite_receipt).unwrap(),
            }),
            proof_chain: vec![Proof {
                image_id: vec![0],
                receipt: vec![0],
            }],
        };
        Ok(Response::new(reply))
    }

    async fn verify(
        &self,
        request: Request<VerifyRequest>,
    ) -> Result<Response<VerifyResponse>, Status> {
        let request = request.into_inner();
        let proof = request.proof.ok_or(Status::invalid_argument("Missing proof"))?;
        let image_id: [u32; 8] = proof.image_id
            .try_into()
            .expect("Failed to convert Vec<u32> to [u32; 8]");
        let receipt: Receipt = bincode::deserialize(&proof.receipt).unwrap();
        //print_type_of(&req.receipt);
        //let receipt = Receipt::from(request.receipt.unwrap());
        let verification_result = receipt.verify(image_id);

        //println!("{:?}",receipt.journal.);
        let reply: VerifyResponse;
        match verification_result {
            Ok(_) => {
                reply = VerifyResponse {
                    is_valid_executed: true,
                    public_output: "public_output".to_string(),
                };
            }
            Err(err) => {
                reply = VerifyResponse {
                    is_valid_executed: false,
                    public_output: "public_output".to_string(),
                };
                println!("{:?}", err)
            }
        }
        Ok(Response::new(reply))
    }
}


fn prove_method(a: f64, b: f64, operation: Operation) -> Receipt {
    let env = ExecutorEnv::builder()
        .write(&(a,b,operation))
        .unwrap()
        .build()
        .unwrap();
    let prover = default_prover();
    // read the input
    let prove_info = prover
        .prove(env, VERIFIABLE_PROCESSING_ELF)
        .unwrap();
    return prove_info.receipt;
}
fn perform_composite_prove(receipts : Vec<Receipt>, image_id: [u32; 8]) -> Result<Receipt,Error> {
    let mut env_builder = ExecutorEnv::builder();
    let mut journals : Vec<([u32;8],f64)> = Vec::new();
    for r in receipts.iter() {
        env_builder.add_assumption(r.clone());
        journals.push((image_id.clone(),r.journal.decode().unwrap()));
    }
    let env = env_builder
        //.write(&image_id)
        //.unwrap()
        .write(&journals)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    // read the input
    let prove = prover
        .prove(env, COMPOSITE_PROVING_ELF);
    match prove {
        Ok(prove_info) => {
            return Ok(prove_info.receipt);
        }
        Err(e) => {
            return Err(e);
        }
    }
}

fn main2() {
    //env_logger::init();
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let receipt1 = prove_method(1.0, 2.0, Operation::Add);
    let receipt2 = prove_method(1.0, 2.0, Operation::Mul);
    let receipt3 = prove_method(1.0, 2.0, Operation::Sub);
    let receipt4 = prove_method(1.0, 2.0, Operation::Div);

    let receipts : Vec<Receipt> = vec![receipt1, receipt2, receipt3, receipt4];//, receipt3, receipt4];
    println!("Receipt vector created");
    let composite_receipt = perform_composite_prove(receipts,VERIFIABLE_PROCESSING_ID).expect("Failed to prove composite receipt");
    // TODO: Implement code for retrieving receipt journal here.

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    println!("Composite receipt created");
    composite_receipt
        .verify(COMPOSITE_PROVING_ID)
        .unwrap();
    
    println!("{:?}",composite_receipt);
}


#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "[::1]:50051".parse()?;
    let prover = MyProver::default();

    println!("GreeterServer listening on {}", addr);

    Server::builder()
        .add_service(VerifiableProcessingServiceServer::new(prover))
        .serve(addr)
        .await?;

    Ok(())
}