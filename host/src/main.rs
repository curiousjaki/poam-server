use qfilter::Filter;
use rules::conformance::{PoamInput, RuleInput};
use rules::event_filter::InsertEvent;
use rules::{CardinalityRule, PrecedenceRule, Rule};
use serde_json;
use std::any::Any;
use std::str::FromStr;
use operations::{OperationRequest,Operation};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::Error;
use methods::{
    PROVE_ID, PROVE_ELF, COMPOSE_ID, COMPOSE_ELF, VERIFY_ID, VERIFY_ELF
};
use host::{prove_method};//,perform_composite_prove};
pub mod proto {
    tonic::include_proto!("poam");
}
use proto::verifiable_processing_service_server::{
    VerifiableProcessingService, VerifiableProcessingServiceServer,
};
use proto::{
    CompositionRequest, CompositionResponse, Proof, ProveRequest, ProveResponse, VerifyRequest,
    VerifyResponse,
};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use tonic::{transport::Server, Request, Response, Status};


#[derive(Default)]
pub struct VerifiableProcessingServiceServerImplementation;

#[tonic::async_trait]
impl VerifiableProcessingService for VerifiableProcessingServiceServerImplementation {
    async fn prove(
        &self,
        request: Request<ProveRequest>,
    ) -> Result<Response<ProveResponse>, Status> {
        println!("Got a request: {:?}", request);

        let request = request.into_inner();

        let previous_proof: Option<Proof> = request
                    .poam_metadata
                    .ok_or(Status::invalid_argument("Missing poam metadata"))?
                    .previous_proof;

        if previous_proof.is_some() {
            let previous_receipt: Receipt = bincode::deserialize(&previous_proof.unwrap().receipt).unwrap();
            let (previous_result_json,previous_metadata_json):(String,String) = previous_receipt.journal.decode().unwrap();
            let pi: PoamInput = PoamInput {
                image_id: PROVE_ID,
                rule_input: RuleInput {
                    rules: None,
                    ordering_rules: None,
                },
                public_data: Some((previous_result_json,previous_metadata_json)),
            };
            let receipt: Receipt = prove_method(
                &request.method_payload,
                &pi,
                Some(previous_receipt),
            );


            let (result_json,metadata_json):(String,String) = receipt.journal.decode().unwrap();
            let reply = ProveResponse {
                //receipt: Some(receipt.into()),
                public_output: result_json,
                proof_response: Some(Proof {
                    image_id: PROVE_ID.to_vec(),
                    receipt: bincode::serialize(&receipt).unwrap(),
                }),
                proof_chain: vec![],
            };
            return Ok(Response::new(reply))
        } else{
            let pi: PoamInput = PoamInput {
                image_id: PROVE_ID,
                rule_input: RuleInput {
                    rules: None,
                    ordering_rules: None,
                },
                public_data: None,
            };
            let receipt: Receipt = prove_method(
                &request.method_payload,
                &pi,
                None,
            );
            let (result_json,metadata_json):(String,String) = receipt.journal.decode().unwrap();
            let reply = ProveResponse {
                //receipt: Some(receipt.into()),
                public_output: result_json,
                proof_response: Some(Proof {
                    image_id: PROVE_ID.to_vec(),
                    receipt: bincode::serialize(&receipt).unwrap(),
                }),
                proof_chain: vec![],
            };
            return Ok(Response::new(reply))
        }
        //let (response_value, qfilter_json): (f64, String) =
        //    receipt.journal.decode::<(f64, String)>().unwrap();
        //let response_2 = receipt.journal.decode().unwrap();

        //let filter: qfilter::Filter = serde_json::from_str(&qfilter_json).unwrap();
        //println!("\n filter: {:?}", &filter);
        //println!("{:?}",filter);
       
    }

    async fn compose(
        &self,
        request: Request<CompositionRequest>,
    ) -> Result<Response<CompositionResponse>, Status> {
        let request = request.into_inner();
        let receipts: Vec<Receipt> = request
            .proof_chain
            .iter()
            .map(|proof| {
                let receipt: Receipt = bincode::deserialize(&proof.receipt).unwrap();
                receipt
            })
            .collect();

        let composite_receipt = "sd";//perform_composite_prove(receipts, VERIFIABLE_PROCESSING_ID)
            //.expect("Failed to prove composite receipt");

        // TODO: Implement code for retrieving receipt journal here.

        let reply = CompositionResponse {
            proof_response: Some(Proof {
                image_id: vec![0],
                receipt: bincode::serialize(&composite_receipt).unwrap(),
            }),
            proof_chain: vec![Proof {
                image_id: vec![0],
                receipt: vec![0],
            }],
        };
        Ok(Response::new(reply))
    }

    async fn verify(
        &self,
        request: Request<VerifyRequest>,
    ) -> Result<Response<VerifyResponse>, Status> {
        let request = request.into_inner();
        let proof = request
            .proof
            .ok_or(Status::invalid_argument("Missing proof"))?;
        let image_id: [u32; 8] = proof
            .image_id
            .try_into()
            .expect("Failed to convert Vec<u32> to [u32; 8]");
        let receipt: Receipt = bincode::deserialize(&proof.receipt).unwrap();
        //print_type_of(&req.receipt);
        //let receipt = Receipt::from(request.receipt.unwrap());
        let verification_result = receipt.verify(image_id);

        //println!("{:?}",receipt.journal.);
        let reply: VerifyResponse;
        match verification_result {
            Ok(_) => {
                reply = VerifyResponse {
                    is_valid_executed: true,
                    public_output: "public_output".to_string(),
                };
            }
            Err(err) => {
                reply = VerifyResponse {
                    is_valid_executed: false,
                    public_output: "public_output".to_string(),
                };
                println!("{:?}", err)
            }
        }
        Ok(Response::new(reply))
    }
}



fn main2() {
    //env_logger::init();
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    println!("Started the Program");
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();
    //let filter = qfilter::Filter::new(1000, 0.01).expect("Failed to create filter");
    //let rule1 = Rule::Cardinality(CardinalityRule{prior: [1,2,3,4,5,6,7,8],max: 1, min: 1});
    //let rule_set: RuleSet = RuleSet{rules: vec![rule1], qf: filter};
    let mut f = Filter::new(100, 0.01).expect("Failed to create filter");
    f.insert_event(PROVE_ID);
    let mut rules: Vec<Rule> = vec![Rule::Precedence(PrecedenceRule {
        //current: VERIFIABLE_PROCESSING_ID,
        preceeding: PROVE_ID,
    })];
    //let cm: ConformanceMetadata = ConformanceMetadata {
    //    previous_image_id: VERIFIABLE_PROCESSING_ID,
    //    current_image_id: VERIFIABLE_PROCESSING_ID,
    //    rules: rules,
    //    qf: f,
    //};
    let method_payload = serde_json::to_string(&OperationRequest{a: 1.0, b: 2.0, operation: Operation::Add }).unwrap();
    //let receipt1 = prove_method(&method_payload, &cm);
    //let receipt2 = prove_method(1.0, 2.0, Operation::Mul, rule_set.clone());
    //let receipt3 = prove_method(1.0, 2.0, Operation::Sub, rule_set.clone());
    //let receipt4 = prove_method(1.0, 2.0, Operation::Div, rule_set);

    //let receipts: Vec<Receipt> = vec![receipt1]; //, receipt2, receipt3, receipt4];//, receipt3, receipt4];
    println!("Receipt vector created");
    //let composite_receipt = perform_composite_prove(receipts, VERIFIABLE_PROCESSING_ID)
    //    .expect("Failed to prove composite receipt");
    // TODO: Implement code for retrieving receipt journal here.

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    //println!("Composite receipt created");
    //composite_receipt.verify(COMPOSITE_PROVING_ID).unwrap();

    //println!("{:?}", composite_receipt);
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "[::1]:50051".parse()?;
    let vpssi: VerifiableProcessingServiceServerImplementation =
        VerifiableProcessingServiceServerImplementation::default();

    println!("VerifiableProcessingService listening on {}", addr);

    Server::builder()
        .add_service(VerifiableProcessingServiceServer::new(vpssi))
        .serve(addr)
        .await?;

    Ok(())
}
